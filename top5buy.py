import json
import os
import math
import alpaca_trade_api as tradeapi
from alpaca_trade_api.rest import TimeFrame

# ---------------------------------------------------------
# CONFIGURATION
# ---------------------------------------------------------
# Alpaca Config (Replace with your actual keys or use env vars)
ALPACA_SCORE_API_KEY = os.getenv("ALPACA_SCORE_API_KEY", "YOUR_KEY_HERE")
ALPACA_SCORE_SECRET_KEY = os.getenv("ALPACA_SCORE_SECRET_KEY", "YOUR_SECRET_HERE")
BASE_URL = "https://paper-api.alpaca.markets" # Use paper for testing

# Trading Params
POSITION_SIZE_USD = 1000  # How much $ to put into each trade
TAKE_PROFIT_PCT = 0.03    # 3% Profit Target
MAX_POSITIONS = 5         # Top 5 tickers

# File Path (Must match where your main script saves data)
SIGNALS_FILE = "data/signals.json"

def get_alpaca_api():
    return tradeapi.REST(ALPACA_API_KEY, ALPACA_SECRET_KEY, BASE_URL, api_version='v2')

def load_signals():
    """Loads the analyzed data from the JSON generated by your main script."""
    if not os.path.exists(SIGNALS_FILE):
        print(f"Error: {SIGNALS_FILE} not found. Run your analysis script first.")
        return []
    
    with open(SIGNALS_FILE, 'r') as f:
        data = json.load(f)
        
    # We only care about the 'buys' list
    buys = data.get('buys', [])
    
    # Sort by 'score' descending (Highest score first)
    # Ensure score exists and default to 0 if missing
    sorted_buys = sorted(buys, key=lambda x: x.get('score', 0), reverse=True)
    
    return sorted_buys[:MAX_POSITIONS]

def place_orders(api, top_picks):
    """
    Places OTO (One-Triggers-Other) orders.
    1. Buy Limit Order @ Current Price.
    2. Sell Limit Order @ +3% (Triggered only after buy fills).
    """
    
    # Get current positions to avoid buying duplicates
    existing_positions = [p.symbol for p in api.list_positions()]
    existing_orders = [o.symbol for o in api.list_orders(status='open')]

    print(f"--- Processing Top {len(top_picks)} Picks ---")

    for stock in top_picks:
        symbol = stock['ticker']
        
        # Skip if we already own it or have an open order
        if symbol in existing_positions or symbol in existing_orders:
            print(f"Skipping {symbol}: Already holds position or open order.")
            continue

        try:
            # Fetch real-time price from Alpaca to ensure Limit is accurate
            # (Your JSON price might be old by the time this runs)
            quote = api.get_latest_trade(symbol)
            current_price = float(quote.price)
            
            # Calculate Quantity
            qty = math.floor(POSITION_SIZE_USD / current_price)
            if qty < 1:
                print(f"Skipping {symbol}: Price ${current_price} too high for position size ${POSITION_SIZE_USD}")
                continue

            # Calculate Take Profit Price
            take_profit_price = round(current_price * (1 + TAKE_PROFIT_PCT), 2)

            print(f"Placing Order: {symbol} | Qty: {qty} | Limit Buy: ${current_price} | TP: ${take_profit_price}")

            # SUBMIT BRACKET ORDER (OTO)
            api.submit_order(
                symbol=symbol,
                qty=qty,
                side='buy',
                type='limit',
                time_in_force='gtc', # Good Till Cancelled
                limit_price=current_price,
                order_class='oto',   # One-Triggers-Other
                take_profit={
                    'limit_price': take_profit_price
                }
            )
            print(f"✅ Order Submitted for {symbol}")

        except Exception as e:
            print(f"❌ Failed to submit order for {symbol}: {e}")

if __name__ == "__main__":
    api = get_alpaca_api()
    
    # Check if market is open (Optional safety check)
    clock = api.get_clock()
    if not clock.is_open:
        print("⚠️ Warning: Market is closed. Orders will be queued for open.")

    top_picks = load_signals()
    
    if not top_picks:
        print("No buy signals found.")
    else:
        place_orders(api, top_picks)
